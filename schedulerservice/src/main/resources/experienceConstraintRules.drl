
import org.optaplanner.core.api.score.buildin.hardsoftlong.HardSoftLongScoreHolder;
import com.tracktik.scheduler.domain.*;
import com.tracktik.scheduler.service.*;
import java.util.*;
import java.time.*;
import java.time.temporal.ChronoUnit;
import java.util.concurrent.TimeUnit
import com.tracktik.scheduler.configuration.HardSkillMissing;
import com.tracktik.scheduler.configuration.SoftSkillMissing;
import com.tracktik.scheduler.configuration.NoExperienceAtSite;
import com.tracktik.scheduler.configuration.NoExperienceAtPost;


global HardSoftLongScoreHolder scoreHolder;

function Long numberOfMatches(Collection first, Collection other) {
    long count = 0;
    for (Object item : first) {
        if (other.contains(item)) count += 1;
    }
    return count;
}

// HARD CONSTRAINTS

/*
    This constraint will ensure that an employee assigned to a post, will have all of the required skills.
    It will only fire if the KeyValueFact of HARD_SKILL_ENABLED false doesn't exist. There is also an option
    where hard skill shall be considered soft in some cases. This rule will only fire if there is no
    KeyValueFact of HARD_SKILL_IS_HARD of false.

rule "MUST_HAVE_HARD_SKILLS"
    when
        not KeyValueFact(key == "HARD_SKILL_ENABLED", value == false)
        not KeyValueFact(key == "HARD_SKILL_IS_HARD", value == false)
        Shift(post != null, employee != null, !employee.skills.containsAll(post.hardSkills))
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end


    This constraint will ensure that an employee assigned to a post will have all of the required skills.
    There is also an option where hard skill shall be considered soft in some cases. This rule is based off of the new
    configuration object, "HardSkillMissing"
*/
rule "hard skills necessary"
    //lock-on-active
    when
        HardSkillMissing(active == true, hardImpact == false, hardFailure == true)
        Shift(post != null, employee != null, !employee.skills.containsAll(post.hardSkills), $employeeId: employee.id)
        not EmployeeConstraintMultiplier($employeeId == employeeId, alreadyFired == true)
        $ecm: EmployeeConstraintMultiplier($employeeId == employeeId, alreadyFired == false)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
        $ecm.setAlreadyFired(true);
        update($ecm);
end

// SOFT CONSTRAINTS

/*
    This constraint will encourage the scheduler to assign an employee that has most or all of the soft skills for a
    post. It will only fire if there is no KeyValueFact of SOFT_SKILL_ENABLED of false and there is no SOFT_SKILL_MUTLIPLIER.
    It computes the number of matches between the post skills and the employee's skills. It then multiplies that by 50 and by the
    employee multiplier.

rule "HAS_SOME_SOFT_SKILLS"
    when
        not KeyValueFact(key == "SOFT_SKILL_ENABLED", value == false)
        not KeyValueFact(key == "SOFT_SKILL_MUTLIPLIER")
        Shift(post != null, employee != null, $employeeId: employee.id, $softSkills: post.softSkills, $skills:employee.skills, numberOfMatches($softSkills, $skills) > 0)
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "HAS_SOME_SOFT_SKILLS", $employeeMultiplier: multiplier)
    then
        Long matches = numberOfMatches($softSkills, $skills);
        Double dValue = matches * 50 * $employeeMultiplier;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
        //System.out.println("has some soft skills" + dValue);
end


    Same as above, but also considers a general multiplier as expressed by SOFT_SKILL_MUTLIPLIER.

rule "MULTIPLIER_HAS_SOME_SOFT_SKILLS"
    when
        Shift(post != null, employee != null, $employeeId: employee.id, $softSkills: post.softSkills, $skills:employee.skills, numberOfMatches($softSkills, $skills) > 0)
        not KeyValueFact(key == "SOFT_SKILL_ENABLED", value == false)
        KeyValueFact(key == "SOFT_SKILL_MUTLIPLIER", $multiplier: ((Long)value))
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "HAS_SOME_SOFT_SKILLS", $employeeMultiplier: multiplier)
    then
        Long matches = numberOfMatches($softSkills, $skills);
        Long matchesSquared = matches * matches;
        Double dValue = matchesSquared * $multiplier * $employeeMultiplier;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
        //System.out.println("multiplier has some soft skills" + dValue);
end
*/
/*
    Same as above, but also considers a general multiplier as expressed by SOFT_SKILL_MUTLIPLIER.
*/
rule "soft skill missing with multiplier"
    when
        SoftSkillMissing(active == true, $impactMultiplier: impactMultiplier, hardImpact == false)
        Shift(post != null, employee != null, $employeeId: employee.id, $softSkills: post.softSkills, $skills:employee.skills, numberOfMatches($softSkills, $skills) > 0)
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "HAS_SOME_SOFT_SKILLS", $employeeMultiplier: multiplier)
    then
        Long matches = numberOfMatches($softSkills, $skills);
        Long matchesSquared = matches * matches;
        Double dValue = matchesSquared * $impactMultiplier * $employeeMultiplier;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
        //System.out.println("multiplier has some soft skills" + dValue);
end

/*
    This is the same as HAS_SOME_SOFT_SKILLS except it is being applied to hard skill instead. This will happen
    when there is a KeyValueFact of HARD_SKILL_IS_HARD that is false.
*/
rule "EMPLOYEE_MUST_HAVE_HARD_SKILLS_AS_SOFT"
    when
        Shift(post != null, employee != null, $hardSkills: post.hardSkills, $skills:employee.skills, numberOfMatches($hardSkills, $skills) > 0)
        not KeyValueFact(key == "HARD_SKILL_ENABLED", value == false)
        KeyValueFact(key == "HARD_SKILL_IS_HARD", value == false)
        KeyValueFact(key == "HARD_SKILL_TYPE_SOFT_MUTLIPLIER", $multiplier: ((Long)value))
    then
        scoreHolder.addSoftConstraintMatch(kcontext, numberOfMatches($hardSkills, $skills) * $multiplier);
        //System.out.println("must have hard skills as soft" + numberOfMatches($hardSkills, $skills) * $multiplier);

end

/*
    This constraint will encourage the scheduler to assign employees to sites where they have experience. It does this
    by checking if the employee has no site experience and then adds a negative soft score. If the employee has a
    EmployeeConstraintMultiplier of HAS_SITE_EXPERIENCE, the score will be multiplied by that as well.

rule "HAS_SITE_EXPERIENCE"
    when
        Shift(employee != null, post != null, $employeeId: employee.id, post.site not memberOf employee.siteExperience)
        $ecm: EmployeeConstraintMultiplier($employeeId == employeeId, name == "HAS_SITE_EXPERIENCE", $multiplier: multiplier, alreadyFired == false)
    then
        Long impact = -100L;
        Double dValue = impact * $multiplier;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
        //System.out.println("has site experience" + dValue);
        $ecm.setAlreadyFired(true);
        update($ecm);
end*/

/*
    This constraint will encourage the scheduler to assign employees to sites where they have experience. It does this
    by checking if the employee has no site experience and then adds a negative soft score. If the employee has a
    EmployeeConstraintMultiplier of HAS_SITE_EXPERIENCE, the score will be multiplied by that as well.
*/
rule "no site experience"
    when
        NoExperienceAtSite(active == true, $scoreImpact: scoreImpact, hardImpact == false)
        Shift(employee != null, post != null, $employeeId: employee.id, post.site not memberOf employee.siteExperience)
        $ecm: EmployeeConstraintMultiplier($employeeId == employeeId, name == "HAS_SITE_EXPERIENCE", $multiplier: multiplier, alreadyFired == false)
    then
        Double dValue = $scoreImpact * $multiplier;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
        //System.out.println("no site experience" + dValue);
        $ecm.setAlreadyFired(true);
        update($ecm);
end

/*
rule "HAS_POST_EXPERIENCE"
    when
        Shift(employee != null, post != null, post not memberOf employee.postExperience)
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "HAS_POST_EXPERIENCE", $multiplier: multiplier)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -100 * $multiplier);
        //System.out.println("has post experience" + (-100*$multiplier));
end
*/

/*
    This constraint will encourage the scheduler to assign employees to sites where they have experience. It does this
    by checking if the employee has no site experience and then adds a negative soft score. If the employee has a
    EmployeeConstraintMultiplier of HAS_SITE_EXPERIENCE, the score will be multiplied by that as well.
*/
rule "no post experience"
    when
        NoExperienceAtPost(active == true, $scoreImpact: scoreImpact, hardImpact == false)
        Shift(employee != null, $employeeId: employee.id, post != null, post not memberOf employee.postExperience)
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "HAS_POST_EXPERIENCE", $multiplier: multiplier)
    then
        Double dValue = $scoreImpact * $multiplier;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
        //System.out.println("has post experience" + ($scoreImpact*$multiplier));
end


/*
    This constraint will encourage the scheduler to prefer employees that have seniority when assigning them to shifts.
    If the specific employee has a multiplier, the score will be multiplied by that as well.
*/
rule "EMPLOYEE_HAS_SENIORITY"
    when
        Shift(employee != null, $employeeId: employee.id)
        Employee($employeeId == id, seniority != null, $seniority: seniority)
        $ecm: EmployeeConstraintMultiplier($employeeId == employeeId, name == "EMPLOYEE_HAS_SENIORITY", $multiplier: multiplier, alreadyFired == false)
    then
        Double dValue = $seniority * $multiplier;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
        //System.out.println("Seniority adds: " + dValue);
        $ecm.setAlreadyFired(true);
        update($ecm);
end
