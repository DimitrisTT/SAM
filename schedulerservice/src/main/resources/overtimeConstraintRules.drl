
import org.optaplanner.core.api.score.buildin.hardsoftlong.HardSoftLongScoreHolder;
import com.tracktik.scheduler.domain.*;
import com.tracktik.scheduler.service.*;
import java.util.*;
import java.time.*;
import java.util.stream.*;
import org.threeten.extra.Interval;

global HardSoftLongScoreHolder scoreHolder;

function Long intervalToHours(Interval interval) {
    return interval.toDuration().toMillis() / 36_000;
}

declare ShiftDate
    date : LocalDate @key
end

// SOFT CONSTRAINTS

/*
    NOTE ON THE FORMAT OF HOURS. In order to avoid floating point math, hours are multiplied by 100. So if a
    shift lasts 1.5 hours, that duration will be carried in the rules as 150.
*/

/*
    For some overtime rules, we need to know the pay periods. If there is no daily overtime, we will look
    at all of the shifts that an employee is assigned and find the earliest and latest dates for all shifts.
    Then we will find the payroll schedule assigned to an employee and use it to calculate all of the pay
    periods that an employee could possibly be paid in. These PayPeriods will be used in other periodic overtime
    calculations.

    The PayPeriod objects are inserted "logically" because we want them to be retracted automatically if
    the shift assignment changes.
*/
rule "Overtime period -- determine periods"
    when
        Employee(overtimeRuleId != null, payScheduleId != null, $employeeId: id, $payrollScheduleId: payScheduleId)
        not HasDayOvertime($employeeId == employeeId)
        exists Shift(employee != null, $employeeId == employee.id)
        accumulate (
          Shift(employee != null, $employeeId == employee.id, $start: start, $end: end),
          $firstDate: min($start),
          $lastDate: max($end)
       )
        $schedule: PayrollSchedule($payrollScheduleId == id)
    then
        for (PayPeriod period : $schedule.enclosingPeriods((LocalDateTime)$firstDate, (LocalDateTime)$lastDate)) {
            insertLogical(period.setId($employeeId));
        }
end

/*
    If there is no daily overtime, the period overtime will be calculated. In this case if an employee is
    assigned to a shift that spans pay periods, the time will be "cut" so that only the time within the period
    will be considered.

    So, when an employee is assigned to a shift and has a payroll schedule that indicates "cut" hours, the hours
    will be summed. If that summation is greater than the minimum hours for overtime, they will be multiplied by 1.5,
    negated and added to the soft score.
*/
rule "Overtime period -- period hours with cut hours overtime"
    when
        Employee(overtimeRuleId != null, payScheduleId != null, $employeeId: id, $payrollScheduleId: payScheduleId, $overtimeRuleId: overtimeRuleId)
        not HasDayOvertime($employeeId == employeeId)
        $schedule: PayrollSchedule($payrollScheduleId == id, overlappingMethod == OverlappingMethodType.CUT)
        $payPeriod: PayPeriod($employeeId == id, $periodStart: start, $periodEnd: end)
        accumulate (
          $shift: Shift(employee != null, $employeeId == employee.id, (start.isEqual($periodStart) || start.isAfter($periodStart)) && end.isBefore($periodEnd)),
          $totalHours: sum($shift.durationHoursDuringPayPeriod($payPeriod))
       )
        PeriodOvertimeDefinition(
            $overtimeRuleId == id,
            overtimeType == "OT",
            $minimumHours: minimumHours,
            $totalHours > (minimumHours * 100)
        )
    then
        Long amount = ($totalHours - ($minimumHours * 100)) * -150 / 100;
        scoreHolder.addSoftConstraintMatch(kcontext, amount);
        System.out.println("Overtime period" + amount);
end

/*
    Double time hours are determined in the same way as overtime. The only difference is that the double time
    is multiplied by 0.5. Since the double time hours have already been multiplied by 1.5, we only need to add
    the additional 0.5.
*/
rule "Overtime period -- period hours with cut hours double time"
    when
        Employee(overtimeRuleId != null, payScheduleId != null, $employeeId: id, $payrollScheduleId: payScheduleId, $overtimeRuleId: overtimeRuleId)
        not HasDayOvertime($employeeId == employeeId)
        $schedule: PayrollSchedule($payrollScheduleId == id, overlappingMethod == OverlappingMethodType.CUT)
        $payPeriod: PayPeriod($employeeId == id, $periodStart: start, $periodEnd: end)
        accumulate (
          $shift: Shift(employee != null, $employeeId == employee.id, (start.isEqual($periodStart) || start.isAfter($periodStart)) && end.isBefore($periodEnd)),
          $totalHours: sum($shift.durationHoursDuringPayPeriod($payPeriod))
       )
        PeriodOvertimeDefinition(
            $overtimeRuleId == id,
            overtimeType == "DBL",
            $minimumHours: minimumHours,
            $totalHours > (minimumHours * 100)
        )
    then
        Long amount = ($totalHours - ($minimumHours * 100)) * -50 / 100;
        scoreHolder.addSoftConstraintMatch(kcontext, amount);
        System.out.println("Double Time Period" + amount);
end

/*
    This rule will calculate the period overtime in the same was as the "cut" overtime rule except that
    if a shift spans a pay period, we will also count any hours that started prior to the period.
*/
rule "Overtime period -- period hours with spanning hours overtime"
    when
        Employee(overtimeRuleId != null, payScheduleId != null, $employeeId: id, $payrollScheduleId: payScheduleId, $overtimeRuleId: overtimeRuleId)
        not HasDayOvertime($employeeId == employeeId)
        $schedule: PayrollSchedule($payrollScheduleId == id, overlappingMethod == OverlappingMethodType.SPAN)
        $payPeriod: PayPeriod($employeeId == id, $periodStart: start, $periodEnd: end)
        accumulate (
          $shift: Shift(employee != null, $employeeId == employee.id, (start.isEqual($periodStart) || start.isAfter($periodStart)) && start.isBefore($periodEnd)),
          $totalHours: sum($shift.durationHoursDuringPayPeriod($payPeriod))
       )
        PeriodOvertimeDefinition(
            $overtimeRuleId == id,
            overtimeType == "OT",
            $minimumHours: minimumHours,
            $totalHours > (minimumHours * 100)
        )
    then
        Long amount = ($totalHours - ($minimumHours * 100)) * -150 / 100;
        scoreHolder.addSoftConstraintMatch(kcontext, amount);
        System.out.println("spanning hours overtime" + amount);
end

/*
    This rule will calculate the period overtime in the same was as the "cut" double time rule except that
    if a shift spans a pay period, we will also count any hours that started prior to the period.
*/
rule "Overtime period -- period hours with spanning hours double time"
    when
        Employee(overtimeRuleId != null, payScheduleId != null, $employeeId: id, $payrollScheduleId: payScheduleId, $overtimeRuleId: overtimeRuleId)
        not HasDayOvertime($employeeId == employeeId)
        $schedule: PayrollSchedule($payrollScheduleId == id, overlappingMethod == OverlappingMethodType.SPAN)
        $payPeriod: PayPeriod($employeeId == id, $periodStart: start, $periodEnd: end)
        accumulate (
          $shift: Shift(employee != null, $employeeId == employee.id, (start.isEqual($periodStart) || start.isAfter($periodStart)) && start.isBefore($periodEnd)),
          $totalHours: sum($shift.durationHoursDuringPayPeriod($payPeriod))
       )
        PeriodOvertimeDefinition(
            $overtimeRuleId == id,
            overtimeType == "DBL",
            $minimumHours: minimumHours,
            $totalHours > (minimumHours * 100)
        )
    then
        Long amount = ($totalHours - ($minimumHours * 100)) * -50 / 100;
        scoreHolder.addSoftConstraintMatch(kcontext, amount);
        System.out.println("spanning hours double time" + amount);
end

/*
    If there is no daily overtime, any holiday overtime will be calculated. If an employee is assigned to a shift and
    a holiday period starts during or at the beginning of that shift we will have holiday overtime for the duration of
    the shift. The shift duration will be multiplied by 1.5 and added to the soft score.
*/
rule "Overtime period -- holiday hours aligned with start"
    when
        Employee(payScheduleId != null, $employeeId: id, $payrollScheduleId: payScheduleId)
        not HasDayOvertime($employeeId == employeeId)
        PayrollSchedule($payrollScheduleId == id, alignHolidaysWithPeriodStartTime, countHolidayHoursTowardsPeriodOvertime)
        $shift: Shift(employee != null, $employeeId == employee.id, $postId: post.id, $shiftInterval: interval)
        $holiday: HolidayPeriod($postId == postId, interval.contains($shiftInterval.getStart()))
    then
        Long amount = Math.round($shift.durationHours() * -1.5);
        scoreHolder.addSoftConstraintMatch(kcontext, amount);
        System.out.println("holiday hours" + amount);
end

/*
    If there is no daily overtime, and the employee is assigned to a shift that includes some or all of that
    holiday period, the overtime will be calculated on the portion of the shift that is during the holiday period.
    That duration will be multiplied by 1.5 and added to the soft score.
*/
rule "Overtime period -- holiday hours cut"
    when
        Employee(payScheduleId != null, $employeeId: id, $payrollScheduleId: payScheduleId)
        not HasDayOvertime($employeeId == employeeId)
        PayrollSchedule($payrollScheduleId == id, !alignHolidaysWithPeriodStartTime, countHolidayHoursTowardsPeriodOvertime)
        $shift: Shift(employee != null, $employeeId == employee.id, $postId: post.id, $shiftInterval: interval)
        $holiday: HolidayPeriod($postId == postId, interval.contains($shiftInterval.getStart()))
    then
        Long amount = intervalToHours($holiday.getInterval().intersection($shift.getInterval()));
        amount = Math.round(amount * -1.5);
        scoreHolder.addSoftConstraintMatch(kcontext, amount);
        System.out.println("Holiday hours cut" + amount);
end

/*
    In order to calculate the daily overtime, we need to know all of the days that an employee is assigned to a shift.
    This rule will add a ShiftDate fact for each date that a shift starts. In order to avoid duplicates, we check to see
    if there is one already.

rule "Overtime daily -- date worked start date"
    when
        Shift($startDate: start.toLocalDate())
        not ShiftDate($startDate == date)
    then
        insert(new ShiftDate($startDate));
end


    A new ShiftDate fact will be inserted for every shift end date if it doesn't already exist.

rule "Overtime daily -- date worked end date"
    when
        Shift($endDate: end.toLocalDate())
        not ShiftDate($endDate == date)
    then
        insert(new ShiftDate($endDate));
end


    If an employee is assigned to a shift, and there is a PayrollSchedule fact tied to that employee that indicates that
    hours should be "cut", then we will sum all of the hours that are worked on a particular shift date. A DailyHours
    fact will be inserted for the employee for later calculations.
*/
rule "Overtime daily -- daily hours cut"
    when
        Employee(overtimeRuleId != null, $employeeId: id, payScheduleId != null, $payrollScheduleId: payScheduleId)
        PayrollSchedule($payrollScheduleId == id, overlappingMethod == OverlappingMethodType.CUT)
        ShiftDate($workDate: date)
        accumulate (
          $shift: Shift(employee != null, $employeeId == employee.id, start.toLocalDate() == $workDate || end.toLocalDate() == $workDate),
          $totalHours: sum($shift.durationHoursOnDate($workDate))
       )

    then
        insertLogical(new DailyHours($employeeId, $workDate, $totalHours));
end

/*
    If an employee is assigned to a shift, and there is a PayrollSchedule fact tied to that employee that indicates that
    hours should be "span", then we will sum all of the hours that are worked on a particular shift even if the end goes into another day.
    A DailyHours fact will be inserted for the employee for later calculations.
*/

rule "Overtime daily -- daily hours span"
    when
        Employee(overtimeRuleId != null, $employeeId: id, payScheduleId != null, $payrollScheduleId: payScheduleId)
        PayrollSchedule($payrollScheduleId == id, overlappingMethod == OverlappingMethodType.SPAN)
        ShiftDate($workDate: date)
        accumulate (
          $shift: Shift(employee != null, $employeeId == employee.id, $workDate == start.toLocalDate()),
          $totalHours: sum($shift.durationHours())
       )
    then
        insertLogical(new DailyHours($employeeId, $workDate, $totalHours));
end

/*
    For each day that an employee worked, we will check the number of hours to see if it is greater than the
    minimum for the DayOvertimeDefinition that is associated with that employee. Those hours will be multiplied
    by 1.5 and added to the soft score.
*/
rule "Overtime daily -- calculate overtime"
    when
        DailyHours($employeeId: employeeId, $hoursWorked: hours)
        Employee($employeeId == id, $overtimeRuleId: overtimeRuleId)
        DayOvertimeDefinition(
            $overtimeRuleId == id,
            overtimeType == "OT",
            $minimumHours: minimumHours,
            $maximumHours: maximumHours,
            $hoursWorked > minimumHours * 100
        )
    then
        insertLogical(new HasDayOvertime($employeeId));
        Long amount = ($hoursWorked - ($minimumHours * 100)) * -150 / 100;
        scoreHolder.addSoftConstraintMatch(kcontext, amount);
        System.out.println("calculate overtime" + amount);
end
/*
    For each day that an employee worked, we will check the number of hours to see if it is greater than the
    minimum for the DayOvertimeDefinition (for double overtime) that is associated with that employee. Those hours will be multiplied
    by 0.5 and added to the soft score. These hours were already multiplied by 1.5 in the overtime rule so we only need the additional 0.5.
*/
rule "Overtime daily -- calculate double-time"
    when
        DailyHours($employeeId: employeeId, $hoursWorked: hours)
        Employee($employeeId == id, $overtimeRuleId: overtimeRuleId)
        DayOvertimeDefinition(
            $overtimeRuleId == id,
            overtimeType == "DBL",
            $minimumHours: minimumHours,
            $maximumHours: maximumHours,
            $hoursWorked > minimumHours * 100
        )
    then
        insertLogical(new HasDayOvertime($employeeId));
        Long amount = ($hoursWorked - ($minimumHours * 100)) * -50 / 100;
        scoreHolder.addSoftConstraintMatch(kcontext, amount);
        System.out.println("calculate double-time" + amount);
end

/*
    If an employee is assigned to shifts that will cause them to work more than the minimum number of days as defined
    in the ConsecutiveDaysOvertimeDefinition, then we will calculate the number of overtime hours for a collection of shifts.
    This rule will collect all shifts that occur during a particular pay period to use in this calculation.
*/
rule "Overtime consecutive -- days"
    when
        Employee(overtimeRuleId != null, $employeeId: id, $overtimeRuleId: overtimeRuleId)
        $definition: ConsecutiveDaysOvertimeDefinition($overtimeRuleId == id, overtimeType == "OT", $minDays: minimumDay, $maxDays: maximumDay)
        $payPeriod: PayPeriod($employeeId == id, $periodStart: start, $periodEnd: end)
        $shifts: List( this.size() > $minDays &&  this.size() <= $maxDays)
            from collect( Shift(employee != null, $employeeId == employee.id, (start.isEqual($periodStart) || start.isAfter($periodStart)) && start.isBefore($periodEnd)) )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, $definition.overtimeHours($shifts) * -1);
end

/*
rule "add cost data"
    when
        $employee: Employee($employeeId: id)
        accumulate(
            Shift(employee == $employee, $hours: hours, $post: post) and Post(this == $post, $billRate: billRate, $payRate: payRate, billRate!= null, payRate != null);
            $totalHours: sum($hours),
            $totalCost: sum($payRate * $hours),
            $totalBilled: sum($billRate * $hours)
        )
     then
     insertLogical(new CostTotals($employee, $totalHours, $totalBilled.longValue(), $totalCost.longValue() ));
end
*/

/*
    There will be a CostTotals fact in memory for every employee assigned to a shift. This rule will
    calculate the margin and divide it by 100 and add to the soft constraint score. It is divided by 100
    because the amounts for pay and bill rates were multiplied by 100 to avoid floating point arithmetic.
*/
/*
rule "NON_OVERTIME_MARGIN"
    when
       CostTotals($margin: totalCost - totalBilled)
    then
       scoreHolder.addSoftConstraintMatch(kcontext, $margin / 100 );
       System.out.println("non-overtime margin" + $margin / 100);
end
*/
/*
rule "OVERTIME_PAY"
    when
        CostTotals(hours>40, $employeeId: employee.id, $otHours: hours - 40, $weightedCost: totalCost/hours) //might have to do rounding instead of truncate
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "OVERTIME_PAY", $multiplier: multiplier)
    then
        Long overtimeCost = ($otHours * $weightedCost / 2) * -1;
        Long costAsDecimal = overtimeCost / 100;
        Double dValue = costAsDecimal * $multiplier;
       scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue() );
       System.out.println("overtime_pay" + dValue);
end
*/
