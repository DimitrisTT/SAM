
import org.optaplanner.core.api.score.buildin.hardsoftlong.HardSoftLongScoreHolder;
import com.tracktik.scheduler.domain.*;
import com.tracktik.scheduler.service.*;
import java.util.*;
import java.time.*;
import java.time.temporal.ChronoUnit;

global HardSoftLongScoreHolder scoreHolder;

function Long numberOfMatches(Collection first, Collection other) {
    return first.stream().filter(item -> other.contains(item)).count();
}

function Long calculateDistance(Double geo1_latitude, Double geo1_longitude, Double geo2_latitude, Double geo2_longitude ) {
    Double distance = ((Math.acos(Math.sin(geo1_latitude * Math.PI / 180D) * Math.sin(geo2_latitude * Math.PI / 180D) + Math.cos(geo1_latitude * Math.PI / 180D) * Math.cos(geo2_latitude * Math.PI / 180D) * Math.cos((geo1_longitude - geo2_longitude) * Math.PI / 180D)) * 180 / Math.PI) * 60 * 1.1515D);
    return distance.longValue();
}

function Boolean overlaps(Date shiftStartDate, Date shiftEndDate, DayOfWeek dayOfWeek, LocalTime availableStartTime, LocalTime availableEndTime) {

    LocalDateTime shiftStart = shiftStartDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime().plus(1L, ChronoUnit.SECONDS);
    LocalDateTime shiftEnd = shiftEndDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime().minus(1L, ChronoUnit.SECONDS);

    LocalDateTime availableStartDateTime = shiftStart.with(dayOfWeek).withHour(availableStartTime.getHour()).withMinute(availableStartTime.getMinute()).withSecond(availableStartTime.getSecond());
    LocalDateTime availableEndDateTime = shiftEnd.with(dayOfWeek).withHour(availableEndTime.getHour()).withMinute(availableEndTime.getMinute()).withSecond(availableEndTime.getSecond());

    Boolean overlaps = shiftEnd.isAfter(availableStartDateTime) && shiftStart.isBefore(availableEndDateTime);

    //System.out.println("Overlaps: " + overlaps + " shiftStart " + shiftStart + " shiftEnd " + shiftEnd + " availableStartDateTime " + availableStartDateTime + " availableEndDateTime " + availableEndDateTime);

    return overlaps;
}

// HARD CONSTRAINTS

rule "employee can not work two shifts at same time"
    when
        $shift: Shift($employee : employee, $timeSlot : timeSlot, employee != null)
        Shift(this != $shift, employee == $employee, (timeSlot.startTime <= $timeSlot.endTime) && ($timeSlot.startTime < timeSlot.endTime))
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "employee must have hard skills"
    when
        Shift(post != null, employee != null, !employee.skills.containsAll(post.hardSkills))
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end


rule "employee has time off scheduled during shift"
    when
        Shift(employee != null, $employeeId: employee.id, $shiftStart: timeSlot.start, $shiftEnd: timeSlot.end)
        TimeOff($employeeId == employeeId, (startTime <= $shiftEnd) && ($shiftStart < endTime))
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "employee is banned from a site"
    when
        Shift(employee != null, $employeeId: employee.id, $siteId: post.site.id)
        SiteBan($employeeId == employeeId, $siteId == siteId)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end


/*rule "there must be 8 hour gap between shifts"
   when
        Shift($employee: employee, $firstShiftEnd: timeSlot.getEnd())
        Shift($employee == employee, hoursGap($firstShiftEnd, timeSlot.getStart()) < 8L)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end*/

// SOFT CONSTRAINTS

rule "has some requested soft skills"
    when
        Shift(post != null, employee != null, $softSkills: post.softSkills, $skills:employee.skills, numberOfMatches($softSkills, $skills) > 0)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, numberOfMatches($softSkills, $skills) * 50 );
end


rule "add cost data"
    when
        $employee: Employee()
        accumulate(
            Shift(employee == $employee, $hours: hours, $post: post) and Post(this == $post, $billRate: billRate, $payRate: payRate, billRate!= null, payRate != null);
            $totalHours: sum($hours),
            $totalCost: sum($payRate * $hours),
            $totalBilled: sum($billRate * $hours)
        )
     then
     insertLogical(new CostTotals($employee, $totalHours, $totalBilled.longValue(), $totalCost.longValue() ));
end


rule "non overtime margin"
    when
       CostTotals($margin: totalCost - totalBilled)
    then
       scoreHolder.addSoftConstraintMatch(kcontext, $margin / 100 );
end

rule "overtime pay"
    when
       CostTotals(hours>40, $otHours: hours - 40, $weightedCost: totalCost/hours) //might have to do rounding instead of truncate
    then
       scoreHolder.addSoftConstraintMatch(kcontext, - ($otHours * $weightedCost / 2)  / 100 );
end

/*rule "maximize profit"
    when
        Shift($post: post, $timeSlot : timeSlot)
        Post(this == $post, $billRate: billRate, $payRate: payRate)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, ($billRate - $payRate)/100L);
end*/

/*
We don't have preferred hours on the employee at this time
rule "minimum availability preference"
    when

        $employee : Employee($preferredHours: preferredHours)
        $totalHours: Long() from accumulate (
           Shift($employee == employee, $shiftHours: timeSlot.getDurationHours()),
           sum($shiftHours)
        )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -(($totalHours - $preferredHours) * ($totalHours - $preferredHours)));
end
*/


rule "has site experience"
    when
        Shift(employee != null, post != null, post.site not memberOf employee.siteExperience)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -100);
end

rule "has post experience"
    when
        Shift(employee != null, post != null, post not memberOf employee.postExperience)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -100);
end

/*
rule "calculate distance from employee to site"
    when
        Shift(plan, employee != null, $employeeId: employee.id, $postId: post.id, $siteId: post.site.id)
        not EmployeeSiteDistance($employeeId == employeeId, $siteId == siteId)
        Employee($employeeId == id, latitude != null, longitude != null, $employeeLatitude: latitude, $employeeLongitude: longitude)
        Site(latitude != null, longitude != null, $siteId == id, $siteLatitude: latitude, $siteLongitute: longitude)
    then
        insert(new EmployeeSiteDistance($employeeId, $siteId, calculateDistance($siteLatitude, $siteLongitute, $employeeLatitude, $employeeLongitude)));
end
*/

rule "workplace is far from employee"
    when
        EmployeeSiteDistance($employeeId: employeeId, $siteId: siteId, distance > 50L)
        Shift(employee != null, employee.id == $employeeId, post.site.id ==$siteId )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -5);
end

rule "workplace is a medium distance from employee"
    when
        EmployeeSiteDistance($employeeId: employeeId, $siteId: siteId, distance > 25L)
        Shift(employee != null, employee.id == $employeeId, post.site.id == $siteId )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -5);
end

rule "workplace is fairly close to employee"
    when
        EmployeeSiteDistance($employeeId: employeeId, $siteId: siteId, distance > 5L)
        Shift(employee != null, employee.id == $employeeId, post.site.id == $siteId )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -5);
end

rule "workplace is close to employee"
    when
        EmployeeSiteDistance($employeeId: employeeId, $siteId: siteId, distance <= 5L)
        Shift(employee != null, employee.id == $employeeId, post.site.id == $siteId )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 5);
end

/*
rule "employee prefers not to work shift"
    when
        $availability : EmployeeAvailability($employeeId: employeeId, type == AvailabilityType.NO, $day: dayOfWeek, $employeeStart: startTime, $employeeEnd: endTime)
        Shift(employee != null, $employeeId == employee.id, this.overlaps($availability))
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -10);
end

rule "employee may be available to work shift"
    when
        Employee($employeeId: id)
        $availability : EmployeeAvailability($employeeId == employeeId, type == AvailabilityType.MAYBE, $startTime: startTime, $endTime: endTime, $day: dayOfWeek)
        Shift(employee != null, $employeeId == employee.id, this.overlaps($availability))
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -5);
end
*/

