
import org.optaplanner.core.api.score.buildin.hardsoftlong.HardSoftLongScoreHolder;
import com.tracktik.scheduler.domain.*;
import com.tracktik.scheduler.service.*;
import java.util.*;
import java.time.*;

global HardSoftLongScoreHolder scoreHolder;

function Long numberOfMatches(Collection first, Collection other) {
    return first.stream().filter(item -> other.contains(item)).count();
}
/*
function Double distance(Double geo1_latitude, Double geo1_longitude, Double geo2_latitude, Double geo2_longitude ) {
    Double distance = ((Math.acos(Math.sin(geo1_latitude * Math.PI / 180D) * Math.sin(geo2_latitude * Math.PI / 180D) + Math.cos(geo1_latitude * Math.PI / 180D) * Math.cos(geo2_latitude * Math.PI / 180D) * Math.cos((geo1_longitude - geo2_longitude) * Math.PI / 180D)) * 180 / Math.PI) * 60 * 1.1515D);
    //System.out.println("Distance: " + distance);
    return distance;
}
*/

// HARD CONSTRAINTS

rule "employee can not work two shifts at same time"
    when
        $shift: Shift($employee : employee, $timeSlot : timeSlot, employee != null)
        Shift(this != $shift, employee == $employee, (timeSlot.startTime <= $timeSlot.endTime) && ($timeSlot.startTime < timeSlot.endTime))
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "employee must have hard skills"
    when
        Shift(post != null, employee != null, !employee.skills.containsAll(post.hardSkills))
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end


rule "employee has time off scheduled during shift"
    when
        Shift(employee != null, $employeeId: employee.id, $shiftStart: timeSlot.start, $shiftEnd: timeSlot.end)
        TimeOff($employeeId == employeeId, (startTime <= $shiftEnd) && ($shiftStart < endTime))
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end


/*rule "there must be 8 hour gap between shifts"
   when
        Shift($employee: employee, $firstShiftEnd: timeSlot.getEnd())
        Shift($employee == employee, hoursGap($firstShiftEnd, timeSlot.getStart()) < 8L)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end*/

// SOFT CONSTRAINTS

rule "has some requested soft skills"
    when
        Shift(post != null, employee != null, $softSkills: post.softSkills, $skills:employee.skills, numberOfMatches($softSkills, $skills) > 0)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, numberOfMatches($softSkills, $skills) * 50 );
end


rule "add cost data"
    when
        $employee: Employee()
        accumulate(
            Shift(employee == $employee, $hours: hours, $post: post) and Post(this == $post, $billRate: billRate, $payRate: payRate, billRate!= null, payRate != null);
            $totalHours: sum($hours),
            $totalCost: sum($payRate * $hours),
            $totalBilled: sum($billRate * $hours)
        )
     then
     insertLogical(new CostTotals($employee, $totalHours, $totalBilled.longValue(), $totalCost.longValue() ));
end


rule "non overtime margin"
    when
       CostTotals($margin: totalCost - totalBilled)
    then
       scoreHolder.addSoftConstraintMatch(kcontext, $margin / 100 );
end

rule "overtime pay"
    when
       CostTotals(hours>40, $otHours: hours - 40, $weightedCost: totalCost/hours) //might have to do rounding instead of truncate
    then
       scoreHolder.addSoftConstraintMatch(kcontext, - ($otHours * $weightedCost / 2)  / 100 );
end

/*rule "maximize profit"
    when
        Shift($post: post, $timeSlot : timeSlot)
        Post(this == $post, $billRate: billRate, $payRate: payRate)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, ($billRate - $payRate)/100L);
end*/

/*
We don't have preferred hours on the employee at this time
rule "minimum availability preference"
    when

        $employee : Employee($preferredHours: preferredHours)
        $totalHours: Long() from accumulate (
           Shift($employee == employee, $shiftHours: timeSlot.getDurationHours()),
           sum($shiftHours)
        )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -(($totalHours - $preferredHours) * ($totalHours - $preferredHours)));
end
*/


rule "has site experience"
    when
        Shift(employee != null, post != null, post.site not memberOf employee.siteExperience)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -100);
end

/*
We don't have post experience at this time
rule "has post experience"
    when
        Shift(employee != null, post != null, post not memberOf employee.postExperience)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -100);
end
*/

/*
Doing this in Java now as a pre-step
rule "calculate distance from employee to site"
    when
        Employee(latitude != null, longitude != null, $employeeId: id, $employeeLatitude: latitude, $employeeLongitude: longitude)
        Shift(employee != null, $employeeId == employee.id, $postId: post.id, plan)
        Post($postId == id, $siteId: site.id)
        Site(latitude != null, longitude != null, $siteId == id, $siteLatitude: latitude, $siteLongitute: longitude)
        not EmployeeSiteDistance($employeeId == employeeId, $siteId == siteId)
    then
        insert(new EmployeeSiteDistance($employeeId, $siteId, distance($siteLatitude, $siteLongitute, $employeeLatitude, $employeeLongitude)));
end
*/

rule "workplace is far from employee"
    when
        Shift(employee != null, $employeeId: employee.id, $siteId: post.site.id)
        EmployeeSiteDistance($employeeId == employeeId, $siteId == siteId, distance > 50L)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -5);
end

/*
rule "workplace is a medium distance from employee"
    when
        Shift(employee != null, $employeeId: employee.id, $siteId: post.site.id)
        Site(latitude != null, longitude != null, $siteId == id, $siteLatitude: latitude, $siteLongitute: longitude)
        Employee(latitude != null, longitude != null, $employeeId == id, distance($siteLatitude, $siteLongitute, latitude, longitude) > 25.0D)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -5);
end
*/
/*
rule "workplace is fairly close to employee"
    when
        Shift(employee != null, $employeeId: employee.id, $siteId: post.site.id)
        Site(latitude != null, longitude != null, $siteId == id, $siteLatitude: latitude, $siteLongitute: longitude)
        Employee(latitude != null, longitude != null, $employeeId == id, distance($siteLatitude, $siteLongitute, latitude, longitude) > 5.0D)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -5);
end
*/
/*
rule "workplace is close to employee"
    when
        Shift(employee != null, $employeeId: employee.id, $siteId: post.site.id)
        Site(latitude != null, longitude != null, $siteId == id, $siteLatitude: latitude, $siteLongitute: longitude)
        Employee(latitude != null, longitude != null, $employeeId == id, distance($siteLatitude, $siteLongitute, latitude, longitude) <= 5.0D)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 5);
end
*/

rule "employee prefers not to work shift"
    when
        Employee($employeeId: id)
        $availability : EmployeeAvailability($employeeId == employeeId, type == AvailabilityType.NO, $startTime: startTime, $endTime: endTime, $day: dayOfWeek)
        Shift(employee != null, $employeeId == employee.id, this.overlaps($availability))
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -10);
end


rule "employee may be available to work shift"
    when
        Employee($employeeId: id)
        $availability : EmployeeAvailability($employeeId == employeeId, type == AvailabilityType.MAYBE, $startTime: startTime, $endTime: endTime, $day: dayOfWeek)
        Shift(employee != null, $employeeId == employee.id, this.overlaps($availability))
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -5);
end

