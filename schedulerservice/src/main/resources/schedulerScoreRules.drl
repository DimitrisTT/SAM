
import org.optaplanner.core.api.score.buildin.hardsoftlong.HardSoftLongScoreHolder;
import com.tracktik.scheduler.domain.*;
import com.tracktik.scheduler.service.*;
import java.util.*;
import java.time.*;
import java.time.temporal.ChronoUnit;
import java.util.concurrent.TimeUnit

global HardSoftLongScoreHolder scoreHolder;

function Long hoursGap(Date startDate, Date endDate) {
    Long gap = TimeUnit.HOURS.convert(endDate.getTime() - startDate.getTime(), TimeUnit.MILLISECONDS);
    return gap;
}

function Long numberOfMatches(Collection first, Collection other) {
    return first.stream().filter(item -> other.contains(item)).count();
}

function Long calculateDistance(Double geo1_latitude, Double geo1_longitude, Double geo2_latitude, Double geo2_longitude ) {
    Double distance = ((Math.acos(Math.sin(geo1_latitude * Math.PI / 180D) * Math.sin(geo2_latitude * Math.PI / 180D) + Math.cos(geo1_latitude * Math.PI / 180D) * Math.cos(geo2_latitude * Math.PI / 180D) * Math.cos((geo1_longitude - geo2_longitude) * Math.PI / 180D)) * 180 / Math.PI) * 60 * 1.1515D);
    return distance.longValue();
}

// HARD CONSTRAINTS

rule "CAN_NOT_WORK_SIMULTANEOUS_SHIFTS"
    when
        $shift: Shift(employee != null, $employee : employee, $timeSlot : timeSlot)
        Shift(this != $shift, employee == $employee, (timeSlot.startTime <= $timeSlot.endTime) && ($timeSlot.startTime < timeSlot.endTime))
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "MUST_HAVE_HARD_SKILLS"
    when
        not KeyValueFact(key == "HARD_SKILL_ENABLED", value == false)
        not KeyValueFact(key == "HARD_SKILL_IS_HARD", value == false)
        Shift(post != null, employee != null, !employee.skills.containsAll(post.hardSkills))
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "TIME_OFF_DURING_SHIFT"
    when
        Shift(employee != null, $employeeId: employee.id, $shiftStart: timeSlot.start, $shiftEnd: timeSlot.end)
        TimeOff($employeeId == employeeId, (startTime <= $shiftEnd) && ($shiftStart < endTime))
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "BANNED_FROM_SITE"
    when
        Shift(employee != null, $employeeId: employee.id, $siteId: post.site.id)
        SiteBan($employeeId == employeeId, $siteId == siteId)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

// SOFT CONSTRAINTS

rule "SHIFT_TAG"
    when
        Shift(employee != null, employee.hasShiftTags(tags), $value: employee.tagValueSummary(tags))
    then
        scoreHolder.addSoftConstraintMatch(kcontext, $value);
end

rule "MINIMUM_REST_PERIOD"
   when
        Shift(employee != null, $employee: employee, $firstShiftEnd: timeSlot.getEnd())
        EmployeeConstraintMultiplier($employee.id == employeeId, name == "MINIMUM_REST_PERIOD", $employeeMultiplier: multiplier)
        Shift($employee == employee, $firstShiftEnd.before(timeSlot.getStart()),$secondShiftStart: timeSlot.getStart(), hoursGap($firstShiftEnd, timeSlot.getStart()) < employee.minimumRestPeriod)
    then
        Long hours = hoursGap($firstShiftEnd, $secondShiftStart);
        Double dValue = hours * hours * $employeeMultiplier * -1;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
end

rule "HAS_SOME_SOFT_SKILLS"
    when
        not KeyValueFact(key == "SOFT_SKILL_ENABLED", value == false)
        not KeyValueFact(key == "SOFT_SKILL_MUTLIPLIER")
        Shift(post != null, employee != null, $employeeId: employee.id, $softSkills: post.softSkills, $skills:employee.skills, numberOfMatches($softSkills, $skills) > 0)
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "HAS_SOME_SOFT_SKILLS", $employeeMultiplier: multiplier)
    then
        Long matches = numberOfMatches($softSkills, $skills);
        Double dValue = matches * 50 * $employeeMultiplier;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
end

rule "MULTIPLIER_HAS_SOME_SOFT_SKILLS"
    when
        Shift(post != null, employee != null, $employeeId: employee.id, $softSkills: post.softSkills, $skills:employee.skills, numberOfMatches($softSkills, $skills) > 0)
        not KeyValueFact(key == "SOFT_SKILL_ENABLED", value == false)
        KeyValueFact(key == "SOFT_SKILL_MUTLIPLIER", $multiplier: ((Long)value))
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "HAS_SOME_SOFT_SKILLS", $employeeMultiplier: multiplier)
    then
        Long matches = numberOfMatches($softSkills, $skills);
        Long matchesSquared = matches * matches;
        Double dValue = matchesSquared * $multiplier * $employeeMultiplier;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
end

rule "EMPLOYEE_MUST_HAVE_HARD_SKILLS_AS_SOFT"
    when
        Shift(post != null, employee != null, $hardSkills: post.hardSkills, $skills:employee.skills, numberOfMatches($hardSkills, $skills) > 0)
        not KeyValueFact(key == "HARD_SKILL_ENABLED", value == false)
        KeyValueFact(key == "HARD_SKILL_IS_HARD", value == false)
        KeyValueFact(key == "HARD_SKILL_TYPE_SOFT_MUTLIPLIER", $multiplier: ((Long)value))
    then
        scoreHolder.addSoftConstraintMatch(kcontext, numberOfMatches($hardSkills, $skills) * $multiplier);
end

rule "add cost data"
    when
        $employee: Employee($employeeId: id)
        accumulate(
            Shift(employee == $employee, $hours: hours, $post: post) and Post(this == $post, $billRate: billRate, $payRate: payRate, billRate!= null, payRate != null);
            $totalHours: sum($hours),
            $totalCost: sum($payRate * $hours),
            $totalBilled: sum($billRate * $hours)
        )
     then
     insertLogical(new CostTotals($employee, $totalHours, $totalBilled.longValue(), $totalCost.longValue() ));
end

rule "NON_OVERTIME_MARGIN"
    when
       CostTotals($margin: totalCost - totalBilled)
    then
       scoreHolder.addSoftConstraintMatch(kcontext, $margin / 100 );
end

rule "OVERTIME_PAY"
    when
        CostTotals(hours>40, $employeeId: employee.id, $otHours: hours - 40, $weightedCost: totalCost/hours) //might have to do rounding instead of truncate
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "OVERTIME_PAY", $multiplier: multiplier)
    then
        Long overtimeCost = ($otHours * $weightedCost / 2) * -1;
        Long costAsDecimal = overtimeCost / 100;
        Double dValue = costAsDecimal * $multiplier;
       scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue() );
end

/*rule "MAXIMIZE_PROFIT"
    when
        Shift($post: post, $timeSlot : timeSlot)
        Post(this == $post, $billRate: billRate, $payRate: payRate)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, ($billRate - $payRate)/100L);
end*/

rule "LESS_THAN_EXPECTED_HOURS"
    when
        $employee : Employee(preferredHours != null, $employeeId: id, $preferredHours: preferredHours)
        not KeyValueFact(key == "LESS_THAN_EXPECTED_ENABLED", value == false)
        KeyValueFact(key == "LESS_THAN_EXPECTED_HOURS_IMPACT", $impact: ((Long)value))
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "LESS_THAN_EXPECTED_HOURS", $multiplier: multiplier)
        $totalHours: Long( longValue < $preferredHours) from accumulate (
           Shift(employee != null, $employee == employee, $shiftHours: timeSlot.getDurationHours()),
           sum($shiftHours)
        )
    then
        Long hoursDifference = $preferredHours - $totalHours;
        Double percentage = hoursDifference.doubleValue() / $preferredHours.doubleValue() * 100D;
        Double dValue =  percentage * $impact * $multiplier * -1;
        //System.out.println("less than expected hours: " + hoursDifference + " expected: " + $preferredHours + " percentage: " + percentage + " dValue: " + dValue);
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
end

rule "MORE_THAN_EXPECTED_HOURS"
    when

        $employee : Employee(preferredHours != null, $employeeId: id, $preferredHours: preferredHours)
        not KeyValueFact(key == "MORE_THAN_EXPECTED_ENABLED", value == false)
        KeyValueFact(key == "MORE_THAN_EXPECTED_HOURS_IMPACT", $impact: ((Long)value))
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "MORE_THAN_EXPECTED_HOURS", $multiplier: multiplier)
        $totalHours: Long( longValue > $preferredHours) from accumulate (
           Shift(employee != null, $employee == employee, $shiftHours: timeSlot.getDurationHours()),
           sum($shiftHours)
        )
    then
        Long hoursDifference = $totalHours - $preferredHours;
        Double percentage = hoursDifference.doubleValue() / $preferredHours.doubleValue() * 100D;
        Double dValue =  percentage * $impact * $multiplier * -1;
        //System.out.println("more than expected hours: " + hoursDifference + " expected: " + $preferredHours + " percentage: " + percentage + " dValue: " + dValue);
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
end

rule "HAS_SITE_EXPERIENCE"
    when
        Shift(employee != null, post != null, $employeeId: employee.id, post.site not memberOf employee.siteExperience)
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "HAS_SITE_EXPERIENCE", $multiplier: multiplier)
    then
        Long impact = -100L;
        Double dValue = impact * $multiplier;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
end

/*
rule "HAS_POST_EXPERIENCE"
    when
        Shift(employee != null, post != null, post not memberOf employee.postExperience)
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "HAS_POST_EXPERIENCE", $multiplier: multiplier)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -100 * $multiplier);
end
*/

rule "EMPLOYEE_HAS_SENIORITY"
    when
        Shift(employee != null, $employeeId: employee.id)
        Employee($employeeId == id, seniority != null, $seniority: seniority)
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "EMPLOYEE_HAS_SENIORITY", $multiplier: multiplier)
    then
        Double dValue = $seniority * $multiplier;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
end

rule "WORKPLACE_FAR"
    when
        not KeyValueFact(key == "FAR_FROM_SITE_ENABLED", value == false)
        KeyValueFact(key == "FAR_FROM_SITE_DEFINITION", $definition: ((Long)value))
        KeyValueFact(key == "FAR_FROM_SITE_IMPACT", $impact: ((Long)value))
        EmployeeSiteDistance($employeeId: employeeId, $siteId: siteId, distance > $definition)
        Shift(employee != null, employee.id == $employeeId, post.site.id ==$siteId )
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "WORKPLACE_FAR", $multiplier: multiplier)
    then
        Double dValue = $impact * $multiplier;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
end

rule "WORKPLACE_FAIRLY_CLOSE"
    when
        not KeyValueFact(key == "FAIRLY_FAR_FROM_SITE_ENABLED", value == false)
        KeyValueFact(key == "FAIRLY_FAR_FROM_SITE_DEFINITION", $definition: ((Long)value))
        KeyValueFact(key == "FAIRLY_FROM_FROM_SITE_IMPACT", $impact: ((Long)value))
        EmployeeSiteDistance($employeeId: employeeId, $siteId: siteId, distance > $definition)
        Shift(employee != null, employee.id == $employeeId, post.site.id == $siteId )
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "WORKPLACE_FAIRLY_CLOSE", $multiplier: multiplier)
    then
        Double dValue = $impact * $multiplier;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
end

rule "WORKPLACE_CLOSE"
    when
        not KeyValueFact(key == "CLOSE_FROM_SITE_ENABLED", value == false)
        KeyValueFact(key == "CLOSE_FROM_SITE_DEFINITION", $definition: ((Long)value))
        KeyValueFact(key == "CLOSE_FROM_SITE_IMPACT", $impact: ((Long)value))
        EmployeeSiteDistance($employeeId: employeeId, $siteId: siteId, distance <= $definition)
        Shift(employee != null, employee.id == $employeeId, post.site.id == $siteId )
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "WORKPLACE_CLOSE", $multiplier: multiplier)
    then
        Double dValue = $impact * $multiplier;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
end

rule "AVAILABILITY_NO"
    when
        $availability : EmployeeAvailability($employeeId: employeeId, type == AvailabilityType.NO, $day: dayOfWeek, $employeeStart: startTime, $employeeEnd: endTime)
        Shift(employee != null, $employeeId == employee.id, this.overlaps($availability))
        not KeyValueFact(key == "AVAILABLE_PREF_NO_ENABLED", value == false)
        KeyValueFact(key == "AVAILABLE_PREF_NO_IMPACT", $impact: ((Long)value))
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "AVAILABILITY_NO", $multiplier: multiplier)
    then
        Double dValue = $impact * $multiplier;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
end

rule "AVAILABILITY_MAYBE"
    when
        Employee($employeeId: id)
        $availability : EmployeeAvailability($employeeId == employeeId, type == AvailabilityType.MAYBE, $startTime: startTime, $endTime: endTime, $day: dayOfWeek)
        Shift(employee != null, $employeeId == employee.id, this.overlaps($availability))
        not KeyValueFact(key == "AVAILABLE_PREF_MAYBE_ENABLED", value == false)
        KeyValueFact(key == "AVAILABLE_PREF_MAYBE_IMPACT", $impact: ((Long)value))
        EmployeeConstraintMultiplier($employeeId == employeeId, name == "AVAILABILITY_MAYBE", $multiplier: multiplier)
    then
        Double dValue = $impact * $multiplier;
        scoreHolder.addSoftConstraintMatch(kcontext, dValue.longValue());
end

rule "CONSECUTIVE_WORK_DAYS"
    when
        Employee($employeeId: id)
        Shift(employee != null, $employeeId == employee.id, $startDate: startDate)
        Shift(employee != null, $employeeId == employee.id, startDate == $startDate.minusDays(1L))
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 100);
end

// DEFAULTS -- We set these if they don't exist so that we won't have to have two sets of rules for each constraint.
// One with the multiplier and one without.

rule "default AVAILABILITY_MAYBE"
    when
        Employee($employeeId: id)
        not EmployeeConstraintMultiplier($employeeId == employeeId, name == "AVAILABILITY_MAYBE")
    then
        insert(new EmployeeConstraintMultiplier().setEmployeeId($employeeId).setName("AVAILABILITY_MAYBE"));
end

rule "default AVAILABILITY_NO"
    when
        Employee($employeeId: id)
        not EmployeeConstraintMultiplier($employeeId == employeeId, name == "AVAILABILITY_NO")
    then
        insert(new EmployeeConstraintMultiplier().setEmployeeId($employeeId).setName("AVAILABILITY_NO"));
end

rule "default EMPLOYEE_HAS_SENIORITY"
    when
        Employee($employeeId: id)
        not EmployeeConstraintMultiplier($employeeId == employeeId, name == "EMPLOYEE_HAS_SENIORITY")
    then
        insert(new EmployeeConstraintMultiplier().setEmployeeId($employeeId).setName("EMPLOYEE_HAS_SENIORITY"));
end

rule "default HAS_SITE_EXPERIENCE"
    when
        Employee($employeeId: id)
        not EmployeeConstraintMultiplier($employeeId == employeeId, name == "HAS_SITE_EXPERIENCE")
    then
        insert(new EmployeeConstraintMultiplier().setEmployeeId($employeeId).setName("HAS_SITE_EXPERIENCE"));
end

rule "default HAS_SOME_SOFT_SKILLS"
    when
        Employee($employeeId: id)
        not EmployeeConstraintMultiplier($employeeId == employeeId, name == "HAS_SOME_SOFT_SKILLS")
    then
        //System.out.println("adding default soft skills multiplier");
        insert(new EmployeeConstraintMultiplier().setEmployeeId($employeeId).setName("HAS_SOME_SOFT_SKILLS"));
end

rule "default LESS_THAN_EXPECTED_HOURS"
    when
        Employee($employeeId: id)
        not EmployeeConstraintMultiplier($employeeId == employeeId, name == "LESS_THAN_EXPECTED_HOURS")
    then
        insert(new EmployeeConstraintMultiplier().setEmployeeId($employeeId).setName("LESS_THAN_EXPECTED_HOURS"));
end

rule "default MINIMUM_REST_PERIOD"
    when
        Employee($employeeId: id)
        not EmployeeConstraintMultiplier($employeeId == employeeId, name == "MINIMUM_REST_PERIOD")
    then
        insert(new EmployeeConstraintMultiplier().setEmployeeId($employeeId).setName("MINIMUM_REST_PERIOD"));
end

rule "default MORE_THAN_EXPECTED_HOURS"
    when
        Employee($employeeId: id)
        not EmployeeConstraintMultiplier($employeeId == employeeId, name == "MORE_THAN_EXPECTED_HOURS")
    then
        insert(new EmployeeConstraintMultiplier().setEmployeeId($employeeId).setName("MORE_THAN_EXPECTED_HOURS"));
end

rule "default OVERTIME_PAY"
    when
        Employee($employeeId: id)
        not EmployeeConstraintMultiplier($employeeId == employeeId, name == "OVERTIME_PAY")
    then
        insert(new EmployeeConstraintMultiplier().setEmployeeId($employeeId).setName("OVERTIME_PAY"));
end

rule "default WORKPLACE_CLOSE"
    when
        Employee($employeeId: id)
        not EmployeeConstraintMultiplier($employeeId == employeeId, name == "WORKPLACE_CLOSE")
    then
        insert(new EmployeeConstraintMultiplier().setEmployeeId($employeeId).setName("WORKPLACE_CLOSE"));
end

rule "default WORKPLACE_FAIRLY_CLOSE"
    when
        Employee($employeeId: id)
        not EmployeeConstraintMultiplier($employeeId == employeeId, name == "WORKPLACE_FAIRLY_CLOSE")
    then
        insert(new EmployeeConstraintMultiplier().setEmployeeId($employeeId).setName("WORKPLACE_FAIRLY_CLOSE"));
end

rule "default WORKPLACE_FAR"
    when
        Employee($employeeId: id)
        not EmployeeConstraintMultiplier($employeeId == employeeId, name == "WORKPLACE_FAR")
    then
        insert(new EmployeeConstraintMultiplier().setEmployeeId($employeeId).setName("WORKPLACE_FAR"));
end

