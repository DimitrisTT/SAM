
import org.optaplanner.core.api.score.buildin.hardsoftlong.HardSoftLongScoreHolder;
import com.tracktik.scheduler.domain.*;
import com.tracktik.scheduler.service.*;
import java.util.*;
import java.time.*;
import java.time.temporal.ChronoUnit;

global HardSoftLongScoreHolder scoreHolder;

function Long numberOfMatches(Collection first, Collection other) {
    return first.stream().filter(item -> other.contains(item)).count();
}

function Long calculateDistance(Double geo1_latitude, Double geo1_longitude, Double geo2_latitude, Double geo2_longitude ) {
    Double distance = ((Math.acos(Math.sin(geo1_latitude * Math.PI / 180D) * Math.sin(geo2_latitude * Math.PI / 180D) + Math.cos(geo1_latitude * Math.PI / 180D) * Math.cos(geo2_latitude * Math.PI / 180D) * Math.cos((geo1_longitude - geo2_longitude) * Math.PI / 180D)) * 180 / Math.PI) * 60 * 1.1515D);
    return distance.longValue();
}

function Boolean overlaps(Date shiftStartDate, Date shiftEndDate, DayOfWeek dayOfWeek, LocalTime availableStartTime, LocalTime availableEndTime) {

    LocalDateTime shiftStart = shiftStartDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime().plus(1L, ChronoUnit.SECONDS);
    LocalDateTime shiftEnd = shiftEndDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime().minus(1L, ChronoUnit.SECONDS);

    LocalDateTime availableStartDateTime = shiftStart.with(dayOfWeek).withHour(availableStartTime.getHour()).withMinute(availableStartTime.getMinute()).withSecond(availableStartTime.getSecond());
    LocalDateTime availableEndDateTime = shiftEnd.with(dayOfWeek).withHour(availableEndTime.getHour()).withMinute(availableEndTime.getMinute()).withSecond(availableEndTime.getSecond());

    Boolean overlaps = shiftEnd.isAfter(availableStartDateTime) && shiftStart.isBefore(availableEndDateTime);

    //System.out.println("Overlaps: " + overlaps + " shiftStart " + shiftStart + " shiftEnd " + shiftEnd + " availableStartDateTime " + availableStartDateTime + " availableEndDateTime " + availableEndDateTime);

    return overlaps;
}

// HARD CONSTRAINTS

rule "CAN_NOT_WORK_SIMULTANEOUS_SHIFTS"
    when
        $shift: Shift($employee : employee, $timeSlot : timeSlot, employee != null)
        Shift(this != $shift, employee == $employee, (timeSlot.startTime <= $timeSlot.endTime) && ($timeSlot.startTime < timeSlot.endTime))
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "MUST_HAVE_HARD_SKILLS"
    when
        Shift(post != null, employee != null, !employee.skills.containsAll(post.hardSkills))
        not KeyValueFact(key == "HARD_SKILL_ENABLED", value == false)
        not KeyValueFact(key == "HARD_SKILL_IS_HARD", value == false)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end


rule "TIME_OFF_DURING_SHIFT"
    when
        Shift(employee != null, $employeeId: employee.id, $shiftStart: timeSlot.start, $shiftEnd: timeSlot.end)
        TimeOff($employeeId == employeeId, (startTime <= $shiftEnd) && ($shiftStart < endTime))
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

rule "BANNED_FROM_SITE"
    when
        Shift(employee != null, $employeeId: employee.id, $siteId: post.site.id)
        SiteBan($employeeId == employeeId, $siteId == siteId)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end


/*rule "EIGHT_HOUR_SHIFT_GAP"
   when
        Shift($employee: employee, $firstShiftEnd: timeSlot.getEnd())
        Shift($employee == employee, hoursGap($firstShiftEnd, timeSlot.getStart()) < 8L)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end*/

// SOFT CONSTRAINTS

rule "HAS_SOME_SOFT_SKILLS"
    when
        Shift(post != null, employee != null, $softSkills: post.softSkills, $skills:employee.skills, numberOfMatches($softSkills, $skills) > 0)
        not KeyValueFact(key == "SOFT_SKILL_ENABLED", value == false)
        not KeyValueFact(key == "SOFT_SKILL_MUTLIPLIER")
    then
        scoreHolder.addSoftConstraintMatch(kcontext, numberOfMatches($softSkills, $skills) * 50 );
end

rule "HAS_SOME_SOFT_SKILLS_MULTIPLIER"
    when
        Shift(post != null, employee != null, $softSkills: post.softSkills, $skills:employee.skills, numberOfMatches($softSkills, $skills) > 0)
        not KeyValueFact(key == "SOFT_SKILL_ENABLED", value == false)
        KeyValueFact(key == "SOFT_SKILL_MUTLIPLIER", $multiplier: ((Long)value))
    then
        System.out.println("found multiplier");
        scoreHolder.addSoftConstraintMatch(kcontext, numberOfMatches($softSkills, $skills) * numberOfMatches($softSkills, $skills) * $multiplier);
end


rule "EMPLOYEE_MUST_HAVE_HARD_SKILLS_AS_SOFT"
    when
        Shift(post != null, employee != null, $hardSkills: post.hardSkills, $skills:employee.skills, numberOfMatches($hardSkills, $skills) > 0)
        not KeyValueFact(key == "HARD_SKILL_ENABLED", value == false)
        KeyValueFact(key == "HARD_SKILL_IS_HARD", value == false)
        KeyValueFact(key == "HARD_SKILL_TYPE_SOFT_MUTLIPLIER", $multiplier: ((Long)value))
    then
        scoreHolder.addSoftConstraintMatch(kcontext, numberOfMatches($hardSkills, $skills) * $multiplier);
end

rule "add cost data"
    when
        $employee: Employee()
        accumulate(
            Shift(employee == $employee, $hours: hours, $post: post) and Post(this == $post, $billRate: billRate, $payRate: payRate, billRate!= null, payRate != null);
            $totalHours: sum($hours),
            $totalCost: sum($payRate * $hours),
            $totalBilled: sum($billRate * $hours)
        )
     then
     insertLogical(new CostTotals($employee, $totalHours, $totalBilled.longValue(), $totalCost.longValue() ));
end


rule "NON_OVERTIME_MARGIN"
    when
       CostTotals($margin: totalCost - totalBilled)
    then
       scoreHolder.addSoftConstraintMatch(kcontext, $margin / 100 );
end

rule "OVERTIME_PAY"
    when
       CostTotals(hours>40, $otHours: hours - 40, $weightedCost: totalCost/hours) //might have to do rounding instead of truncate
    then
       scoreHolder.addSoftConstraintMatch(kcontext, - ($otHours * $weightedCost / 2)  / 100 );
end

/*rule "MAXIMIZE_PROFIT"
    when
        Shift($post: post, $timeSlot : timeSlot)
        Post(this == $post, $billRate: billRate, $payRate: payRate)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, ($billRate - $payRate)/100L);
end*/

rule "MINIMUM_AVAILABILITY_PREFERENCE"
    when

        $employee : Employee(preferredHours != null, $preferredHours: preferredHours)
        $totalHours: Long() from accumulate (
           Shift(employee != null, $employee == employee, $shiftHours: timeSlot.getDurationHours()),
           sum($shiftHours)
        )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -(($totalHours - $preferredHours) * ($totalHours - $preferredHours)));
end



rule "HAS_SITE_EXPERIENCE"
    when
        Shift(employee != null, post != null, post.site not memberOf employee.siteExperience)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -100);
end

rule "HAS_POST_EXPERIENCE"
    when
        Shift(employee != null, post != null, post not memberOf employee.postExperience)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -100);
end

rule "EMPLOYEE_HAS_SENIORITY"
    when
        Shift(employee != null, $employeeId: employee.id)
        Employee($employeeId == id, seniority != null, $seniority: seniority)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, $seniority);
end

/*
rule "calculate distance from employee to site"
    when
        Shift(plan, employee != null, $employeeId: employee.id, $postId: post.id, $siteId: post.site.id)
        not EmployeeSiteDistance($employeeId == employeeId, $siteId == siteId)
        Employee($employeeId == id, latitude != null, longitude != null, $employeeLatitude: latitude, $employeeLongitude: longitude)
        Site(latitude != null, longitude != null, $siteId == id, $siteLatitude: latitude, $siteLongitute: longitude)
    then
        insert(new EmployeeSiteDistance($employeeId, $siteId, calculateDistance($siteLatitude, $siteLongitute, $employeeLatitude, $employeeLongitude)));
end
*/

rule "WORKPLACE_FAR"
    when
        not KeyValueFact(key == "FAR_FROM_SITE_ENABLED", value == false)
        KeyValueFact(key == "FAR_FROM_SITE_DEFINITION", $definition: ((Long)value))
        KeyValueFact(key == "FAR_FROM_SITE_IMPACT", $impact: ((Long)value))
        EmployeeSiteDistance($employeeId: employeeId, $siteId: siteId, distance > $definition)
        Shift(employee != null, employee.id == $employeeId, post.site.id ==$siteId )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, $impact);
end

rule "WORKPLACE_FAIRLY_CLOSE"
    when
        not KeyValueFact(key == "FAIRLY_FAR_FROM_SITE_ENABLED", value == false)
        KeyValueFact(key == "FAIRLY_FAR_FROM_SITE_DEFINITION", $definition: ((Long)value))
        KeyValueFact(key == "FAIRLY_FROM_FROM_SITE_IMPACT", $impact: ((Long)value))
        EmployeeSiteDistance($employeeId: employeeId, $siteId: siteId, distance > $definition)
        Shift(employee != null, employee.id == $employeeId, post.site.id == $siteId )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, $impact);
end

rule "WORKPLACE_CLOSE"
    when
        not KeyValueFact(key == "CLOSE_FROM_SITE_ENABLED", value == false)
        KeyValueFact(key == "CLOSE_FROM_SITE_DEFINITION", $definition: ((Long)value))
        KeyValueFact(key == "CLOSE_FROM_SITE_IMPACT", $impact: ((Long)value))
        EmployeeSiteDistance($employeeId: employeeId, $siteId: siteId, distance <= $definition)
        Shift(employee != null, employee.id == $employeeId, post.site.id == $siteId )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, $impact);
end

rule "employee prefers not to work shift"
    when
        $availability : EmployeeAvailability($employeeId: employeeId, type == AvailabilityType.NO, $day: dayOfWeek, $employeeStart: startTime, $employeeEnd: endTime)
        Shift(employee != null, $employeeId == employee.id, this.overlaps($availability))
        not KeyValueFact(key == "AVAILABLE_PREF_NO_ENABLED", value == false)
        KeyValueFact(key == "AVAILABLE_PREF_NO_IMPACT", $impact: ((Long)value))
    then
        scoreHolder.addSoftConstraintMatch(kcontext, $impact);
end

rule "employee may be available to work shift"
    when
        Employee($employeeId: id)
        $availability : EmployeeAvailability($employeeId == employeeId, type == AvailabilityType.MAYBE, $startTime: startTime, $endTime: endTime, $day: dayOfWeek)
        Shift(employee != null, $employeeId == employee.id, this.overlaps($availability))
        not KeyValueFact(key == "AVAILABLE_PREF_MAYBE_ENABLED", value == false)
        KeyValueFact(key == "AVAILABLE_PREF_MAYBE_IMPACT", $impact: ((Long)value))
    then
        scoreHolder.addSoftConstraintMatch(kcontext, $impact);
end


